/*******************************************************************************
 * Stefan Bylund 2017
 *
 * Program for converting the palette in an uncompressed 8-bit BMP file to
 * Sinclair ZX Spectrum Next format. The original RGB888 colors in the palette
 * are converted to RGB333 colors and then back to their equivalent RGB888
 * colors. If no destination BMP file is specified, the source BMP file is
 * modified. This program is suitable for converting BMP files for layer 2
 * graphics and sprites.
 *
 * Note that when the original RGB888 colors in the palette are converted to
 * RGB333 colors, the resulting 3-bit color components may not end up as
 * integers and must be rounded to an integer (0 - 7). By default, the 3-bit
 * color components are rounded to the nearest integer (-round). However,
 * depending on the original RGB888 colors, this may not always be the best
 * choice. Sometimes, better results are achieved by rounding upwards (-ceil)
 * or downwards (-floor).
 *
 * If the -std-palette option is specified, the original RGB888 colors in the
 * palette are converted to the Spectrum Next standard palette RGB332 colors
 * (which are extended to RGB333 colors when displayed). This is useful if you
 * need to use the standard palette. However, better results are generally
 * achieved when converting to the closest matching RGB333 colors.
 *
 * Note: Use the nextraw companion tool to convert the BMP file generated by
 * nextbmp to a raw image file for Sinclair ZX Spectrum Next.
 *
 * This program is inspired by Jim Bagley's BMPtoNext tool but with added
 * support for the Spectrum Next RGB333 palette and with more options and
 * validations.
 ******************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define FILE_HEADER_SIZE 14
#define MIN_DIB_HEADER_SIZE 40
#define HEADER_SIZE 54
#define PALETTE_SIZE 1024
#define STD_PALETTE_SIZE 256
#define MIN_BMP_FILE_SIZE 1082

typedef enum rounding_mode
{
    FLOOR,
    CEIL,
    ROUND,
    DEFAULT
} rounding_mode_t;

static uint8_t header[HEADER_SIZE];

static uint8_t palette[PALETTE_SIZE];

static uint8_t std_palette_index[STD_PALETTE_SIZE];

static uint8_t *image;

static void print_usage(void)
{
    printf("Usage: nextbmp [-floor|-ceil|-round] [-std-palette] <srcfile.bmp> [<dstfile.bmp>]\n");
    printf("Convert the palette in an uncompressed 8-bit BMP file to Sinclair ZX Spectrum Next format.\n");
    printf("If no destination BMP file is specified, the source BMP file is modified.\n");
    printf("\n");
    printf("Options:\n");
    printf("  -floor   Round down the color values to the nearest integer.\n");
    printf("  -ceil    Round up the color values to the nearest integer.\n");
    printf("  -round   Round the color values to the nearest integer.\n");
    printf("           Default if no rounding mode option is specified.\n");
    printf("  -std-palette   If specified, convert to the Spectrum Next standard palette colors.\n");
}

static void exit_with_msg(const char *format, ...)
{
  va_list args;
  va_start(args, format);
  vfprintf(stderr, format, args);
  va_end(args);

  exit(EXIT_FAILURE);
}

static rounding_mode_t get_rounding_mode(char *s)
{
    if (!strcmp(s, "-floor"))
    {
        return FLOOR;
    }
    else if (!strcmp(s, "-ceil"))
    {
        return CEIL;
    }
    else if (!strcmp(s, "-round"))
    {
        return ROUND;
    }
    else
    {
        return DEFAULT;
    }
}

static bool is_valid_bmp_file(uint32_t *palette_offset,
                              uint32_t *image_offset,
                              uint32_t *image_width,
                              int32_t *image_height)
{
    if ((header[0] != 'B') || (header[1] != 'M'))
    {
        fprintf(stderr, "Not a BMP file.\n");
        return false;
    }

    uint32_t file_size = *((uint32_t *) (header + 2));
    if (file_size < MIN_BMP_FILE_SIZE)
    {
        fprintf(stderr, "Invalid size of BMP file.\n");
        return false;
    }

    *image_offset = *((uint32_t *) (header + 10));
    if (*image_offset >= file_size)
    {
        fprintf(stderr, "Invalid header of BMP file.\n");
        return false;
    }

    uint32_t dib_header_size = *((uint32_t *) (header + 14));
    if (dib_header_size < MIN_DIB_HEADER_SIZE)
    {
        // At least a BITMAPINFOHEADER is required.
        fprintf(stderr, "Invalid/unsupported header of BMP file.\n");
        return false;
    }

    *palette_offset = FILE_HEADER_SIZE + dib_header_size;

    *image_width = *((uint32_t *) (header + 18));
    if (*image_width == 0)
    {
        fprintf(stderr, "Invalid image width in BMP file.\n");
        return false;
    }

    *image_height = *((int32_t *) (header + 22));
    if (*image_height == 0)
    {
        fprintf(stderr, "Invalid image height in BMP file.\n");
        return false;
    }

    if (*image_width * abs(*image_height) >= file_size)
    {
        fprintf(stderr, "Invalid image size in BMP file.\n");
        return false;
    }

    uint16_t bpp = *((uint16_t *) (header + 28));
    if (bpp != 8)
    {
        fprintf(stderr, "Not an 8-bit BMP file.\n");
        return false;
    }

    uint32_t compression = *((uint32_t *) (header + 30));
    if (compression != 0)
    {
        fprintf(stderr, "Not an uncompressed BMP file.\n");
        return false;
    }

    return true;
}

static void free_image(void)
{
    if (image != NULL)
    {
        free(image);
        image = NULL;
    }
}

static uint8_t c8_to_c3(uint8_t c8, rounding_mode_t rounding_mode)
{
    double c3 = (c8 * 7.0) / 255.0;

    switch (rounding_mode)
    {
        case FLOOR:
            return (uint8_t) floor(c3);
        case CEIL:
            return (uint8_t) ceil(c3);
        case ROUND:
            // Fall through
        default:
            return (uint8_t) round(c3);
    }
}

static uint8_t c8_to_c2(uint8_t c8, rounding_mode_t rounding_mode)
{
    double c2 = (c8 * 3.0) / 255.0;

    switch (rounding_mode)
    {
        case FLOOR:
            return (uint8_t) floor(c2);
        case CEIL:
            return (uint8_t) ceil(c2);
        case ROUND:
            // Fall through
        default:
            return (uint8_t) round(c2);
    }
}

static uint8_t c2_to_c3(uint8_t c2)
{
    return (c2 << 1) | (((c2 >> 1) | c2) & 0x01);
}

static uint8_t c3_to_c8(uint8_t c3)
{
    return (uint8_t) round((c3 * 255.0) / 7.0);
}

static void convert_palette(rounding_mode_t rounding_mode)
{
    // Update the colors in the palette.
    // The original RGB888 colors in the palette are converted to
    // RGB333 colors and then back to their equivalent RGB888 colors.
    for (int i = 0; i < 256; i++)
    {
        // BMP palette contains BGRA colors.
        uint8_t r8 = palette[i * 4 + 2];
        uint8_t g8 = palette[i * 4 + 1];
        uint8_t b8 = palette[i * 4 + 0];

        uint8_t r3 = c8_to_c3(r8, rounding_mode);
        uint8_t g3 = c8_to_c3(g8, rounding_mode);
        uint8_t b3 = c8_to_c3(b8, rounding_mode);

        r8 = c3_to_c8(r3);
        g8 = c3_to_c8(g3);
        b8 = c3_to_c8(b3);

        palette[i * 4 + 3] = 0;
        palette[i * 4 + 2] = r8;
        palette[i * 4 + 1] = g8;
        palette[i * 4 + 0] = b8;
    }
}

static void convert_standard_palette(rounding_mode_t rounding_mode)
{
    // Update the colors in the palette.
    // The original RGB888 colors in the palette are converted to the RGB332/
    // RGB333 colors in the standard palette and then back to their equivalent
    // RGB888 colors.
    for (int i = 0; i < 256; i++)
    {
        // BMP palette contains BGRA colors.
        uint8_t r8 = palette[i * 4 + 2];
        uint8_t g8 = palette[i * 4 + 1];
        uint8_t b8 = palette[i * 4 + 0];

        // Convert the RGB888 color to an RGB332 color.
        // The RGB332 value is also the index for this color in the standard
        // palette. The pixels having palette index i will be updated with this
        // new palette index which points to the new location of the converted
        // RGB888 color that was originally stored at index i.
        uint8_t r3 = c8_to_c3(r8, rounding_mode);
        uint8_t g3 = c8_to_c3(g8, rounding_mode);
        uint8_t b2 = c8_to_c2(b8, rounding_mode);
        std_palette_index[i] = (r3 << 5) | (g3 << 2) | (b2 << 0);

        // Create the standard RGB332/RGB333 color for this palette index.
        // The standard RGB332 color has the same value as its index in the
        // standard palette. The actual color displayed on the Spectrum Next
        // is an RGB333 color where the lowest blue bit as a bitwise OR between
        // the two blue bits in the RGB332 color.
        uint8_t std_r3 = (uint8_t) ((i >> 5) & 0x07);
        uint8_t std_g3 = (uint8_t) ((i >> 2) & 0x07);
        uint8_t std_b2 = (uint8_t) ((i >> 0) & 0x03);
        uint8_t std_b3 = c2_to_c3(std_b2);

        // Convert the standard RGB333 color back to an RGB888 color.
        r8 = c3_to_c8(std_r3);
        g8 = c3_to_c8(std_g3);
        b8 = c3_to_c8(std_b3);

        // Update the palette with the RGB888 representation of the standard RGB333 color.
        palette[i * 4 + 3] = 0;
        palette[i * 4 + 2] = r8;
        palette[i * 4 + 1] = g8;
        palette[i * 4 + 0] = b8;
    }
}

static bool copy_file(FILE *src_file, FILE *dst_file)
{
    uint8_t buffer[BUFSIZ];
    size_t num_read;

    while ((num_read = fread(buffer, sizeof(uint8_t), sizeof(buffer), src_file)) > 0)
    {
        if (fwrite(buffer, sizeof(uint8_t), num_read, dst_file) != num_read)
        {
            return false;
        }
    }

    return true;
}

int main(int argc, char *argv[])
{
    uint32_t palette_offset;
    uint32_t image_offset;
    uint32_t image_width;
    int32_t image_height;
    bool use_std_palette = true; // FIXME

    if ((argc < 2) || (argc > 5))
    {
        print_usage();
        return 0;
    }

    // Parse program arguments.
    rounding_mode_t rounding_mode = get_rounding_mode(argv[1]);
    bool default_rounding_mode = (rounding_mode == DEFAULT);
    if (!default_rounding_mode && (argc == 2))
    {
        print_usage();
        return 0;
    }
    bool create_new_file = (argc == 4) || ((argc == 3) && default_rounding_mode);
    char *in_filename = default_rounding_mode ? argv[1] : argv[2];
    char *out_filename = create_new_file ? (default_rounding_mode ? argv[2] : argv[3]) : in_filename;
    if (create_new_file && !strcmp(in_filename, out_filename))
    {
        create_new_file = false;
    }

    // Open the BMP file and validate its header.
    FILE *in_file = fopen(in_filename, "rb");
    if (in_file == NULL)
    {
        exit_with_msg("Can't open file %s.\n", in_filename);
    }
    if (fread(header, sizeof(uint8_t), sizeof(header), in_file) != sizeof(header))
    {
        exit_with_msg("Can't read the BMP header in file %s.\n", in_filename);
    }
    if (!is_valid_bmp_file(&palette_offset, &image_offset, &image_width, &image_height))
    {
        exit_with_msg("The file %s is not a valid or supported BMP file.\n", in_filename);
    }

    // Calculate image size.
    // Note: Image width is padded to a multiple of 4 bytes.
    uint32_t padded_image_width = (image_width + 3) & ~0x03;
    image_height = abs(image_height);
    uint32_t image_size = padded_image_width * image_height;
    if (use_std_palette)
    {
        // Allocate memory for image data.
        image = malloc(image_size);
        if (image == NULL)
        {
            exit_with_msg("Can't allocate memory for image data.\n");
        }
        atexit(free_image);
    }

    // Read the palette and image data.
    if (fseek(in_file, palette_offset, SEEK_SET) != 0)
    {
        exit_with_msg("Can't access the BMP palette in file %s.\n", in_filename);
    }
    if (fread(palette, sizeof(uint8_t), sizeof(palette), in_file) != sizeof(palette))
    {
        exit_with_msg("Can't read the BMP palette in file %s.\n", in_filename);
    }
    if (use_std_palette)
    {
        if (fseek(in_file, image_offset, SEEK_SET) != 0)
        {
            exit_with_msg("Can't access the BMP image data in file %s.\n", in_filename);
        }
        if (fread(image, sizeof(uint8_t), image_size, in_file) != image_size)
        {
            exit_with_msg("Can't read the BMP image data in file %s.\n", in_filename);
        }
    }
    fclose(in_file);

    // Update the colors in the palette.
    if (use_std_palette)
    {
        // Convert the colors in the palette to the Spectrum Next standard palette RGB332 colors.
        convert_standard_palette(rounding_mode);

        // Update the image pixels to use the new palette indexes of the standard palette colors.
        for (int i = 0; i < image_size; i++)
        {
            image[i] = std_palette_index[image[i]];
        }
    }
    else
    {
        // Convert the colors in the palette to the closest matching RGB333 colors.
        convert_palette(rounding_mode);
    }

    // Write the updated palette and, if the standard palette is used, the updated image data.
    // Update the original BMP file or a copy of it.
    FILE *out_file = fopen(out_filename, create_new_file ? "wb" : "r+b");
    if (out_file == NULL)
    {
        exit_with_msg("Can't open file %s.\n", out_filename);
    }
    if (create_new_file)
    {
        in_file = fopen(in_filename, "rb");
        if (in_file == NULL)
        {
            exit_with_msg("Can't open file %s.\n", in_filename);
        }
        if (!copy_file(in_file, out_file))
        {
            exit_with_msg("Can't copy file %s to %s.\n", in_filename, out_filename);
        }
        fclose(in_file);
    }
    if (fseek(out_file, palette_offset, SEEK_SET) != 0)
    {
        exit_with_msg("Can't access the BMP palette in file %s.\n", out_filename);
    }
    if (fwrite(palette, sizeof(uint8_t), sizeof(palette), out_file) != sizeof(palette))
    {
        exit_with_msg("Can't write the BMP palette in file %s.\n", out_filename);
    }
    if (use_std_palette)
    {
        if (fseek(out_file, image_offset, SEEK_SET) != 0)
        {
            exit_with_msg("Can't access the BMP image data in file %s.\n", out_filename);
        }
        if (fwrite(image, sizeof(uint8_t), image_size, out_file) != image_size)
        {
            exit_with_msg("Can't write the BMP image data in file %s.\n", out_filename);
        }
    }
    fclose(out_file);

    return 0;
}

/*******************************************************************************
 * Stefan Bylund 2017
 *
 * Program for converting the palette in an uncompressed 8-bit BMP file to
 * Sinclair ZX Spectrum Next format. The original RGB888 colors in the palette
 * are converted to RGB333 colors and then back to their equivalent RGB888
 * colors. If no destination BMP file is specified, the source BMP file is
 * modified. This program is suitable for converting BMP files for layer 2
 * graphics and sprites.
 *
 * Note that when the original RGB888 colors in the palette are converted to
 * RGB333 colors, the resulting 3-bit color components may not end up as
 * integers and must be rounded to an integer (0 - 7). By default, the 3-bit
 * color components are rounded to the nearest integer (-round). However,
 * depending on the original RGB888 colors, this may not always be the best
 * choice. Sometimes, better results are achieved by rounding upwards (-ceil)
 * or downwards (-floor).
 *
 * Note: Use the nextraw companion tool to convert the BMP file generated by
 * nextbmp to a raw image file for Sinclair ZX Spectrum Next.
 *
 * This program is inspired by Jim Bagley's BMPtoNext tool but with added
 * support for the Spectrum Next RGB333 palette and with more options and
 * validations.
 ******************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define FILE_HEADER_SIZE 14
#define MIN_DIB_HEADER_SIZE 40
#define HEADER_SIZE 54
#define PALETTE_SIZE 1024
#define MIN_BMP_FILE_SIZE 1082

typedef enum rounding_mode
{
    FLOOR,
    CEIL,
    ROUND,
    DEFAULT
} rounding_mode_t;

static uint8_t header[HEADER_SIZE];

static uint8_t palette[PALETTE_SIZE];

static void print_usage(void)
{
    printf("Usage: nextbmp [-floor|-ceil|-round] <srcfile.bmp> [<dstfile.bmp>]\n");
    printf("Convert the palette in an uncompressed 8-bit BMP file to Sinclair ZX Spectrum Next format.\n");
    printf("If no destination BMP file is specified, the source BMP file is modified.\n");
    printf("\n");
    printf("Rounding mode options when downscaling from RGB888 to RGB333 colors:\n");
    printf("  -floor   Round down the color values to the nearest integer.\n");
    printf("  -ceil    Round up the color values to the nearest integer.\n");
    printf("  -round   Round the color values to the nearest integer.\n");
    printf("           Default if no rounding mode option is specified.\n");
}

static void exit_with_msg(const char *format, ...)
{
  va_list args;
  va_start(args, format);
  vfprintf(stderr, format, args);
  va_end(args);

  exit(EXIT_FAILURE);
}

static rounding_mode_t get_rounding_mode(char *s)
{
    if (!strcmp(s, "-floor"))
    {
        return FLOOR;
    }
    else if (!strcmp(s, "-ceil"))
    {
        return CEIL;
    }
    else if (!strcmp(s, "-round"))
    {
        return ROUND;
    }
    else
    {
        return DEFAULT;
    }
}

static bool is_valid_bmp_file(uint32_t *palette_offset)
{
    if ((header[0] != 'B') || (header[1] != 'M'))
    {
        fprintf(stderr, "Not a BMP file.\n");
        return false;
    }

    uint32_t file_size = *((uint32_t *) (header + 2));
    if (file_size < MIN_BMP_FILE_SIZE)
    {
        fprintf(stderr, "Invalid size of BMP file.\n");
        return false;
    }

    uint32_t dib_header_size = *((uint32_t *) (header + 14));
    if (dib_header_size < MIN_DIB_HEADER_SIZE)
    {
        // At least a BITMAPINFOHEADER is required.
        fprintf(stderr, "Invalid/unsupported header of BMP file.\n");
        return false;
    }

    *palette_offset = FILE_HEADER_SIZE + dib_header_size;

    uint16_t bpp = *((uint16_t *) (header + 28));
    if (bpp != 8)
    {
        fprintf(stderr, "Not an 8-bit BMP file.\n");
        return false;
    }

    uint32_t compression = *((uint32_t *) (header + 30));
    if (compression != 0)
    {
        fprintf(stderr, "Not an uncompressed BMP file.\n");
        return false;
    }

    return true;
}

static uint8_t c8_to_c3(uint8_t c8, rounding_mode_t rounding_mode)
{
    double c3 = (c8 * 7.0) / 255.0;

    switch (rounding_mode)
    {
        case FLOOR:
            return (uint8_t) floor(c3);
        case CEIL:
            return (uint8_t) ceil(c3);
        case ROUND:
            // Fall through
        default:
            return (uint8_t) round(c3);
    }
}

static uint8_t c3_to_c8(uint8_t c3)
{
    return (uint8_t) round((c3 * 255.0) / 7.0);
}

static void convert_palette(rounding_mode_t rounding_mode)
{
    // Update the colors in the palette.
    // The original RGB888 colors in the palette are converted to
    // RGB333 colors and then back to their equivalent RGB888 colors.
    for (int i = 0; i < 256; i++)
    {
        // BMP palette contains BGRA colors.
        uint8_t r8 = palette[i * 4 + 2];
        uint8_t g8 = palette[i * 4 + 1];
        uint8_t b8 = palette[i * 4 + 0];

        uint8_t r3 = c8_to_c3(r8, rounding_mode);
        uint8_t g3 = c8_to_c3(g8, rounding_mode);
        uint8_t b3 = c8_to_c3(b8, rounding_mode);

        r8 = c3_to_c8(r3);
        g8 = c3_to_c8(g3);
        b8 = c3_to_c8(b3);

        palette[i * 4 + 3] = 0;
        palette[i * 4 + 2] = r8;
        palette[i * 4 + 1] = g8;
        palette[i * 4 + 0] = b8;
    }
}

static bool copy_file(FILE *src_file, FILE *dst_file)
{
    uint8_t buffer[BUFSIZ];
    size_t num_read;

    while ((num_read = fread(buffer, sizeof(uint8_t), sizeof(buffer), src_file)) > 0)
    {
        if (fwrite(buffer, sizeof(uint8_t), num_read, dst_file) != num_read)
        {
            return false;
        }
    }

    return true;
}

int main(int argc, char *argv[])
{
    uint32_t palette_offset;

    if ((argc < 2) || (argc > 4))
    {
        print_usage();
        return 0;
    }

    // Parse program arguments.
    rounding_mode_t rounding_mode = get_rounding_mode(argv[1]);
    bool default_rounding_mode = (rounding_mode == DEFAULT);
    if (!default_rounding_mode && (argc == 2))
    {
        print_usage();
        return 0;
    }
    bool create_new_file = (argc == 4) || ((argc == 3) && default_rounding_mode);
    char *in_filename = default_rounding_mode ? argv[1] : argv[2];
    char *out_filename = create_new_file ? (default_rounding_mode ? argv[2] : argv[3]) : in_filename;
    if (create_new_file && !strcmp(in_filename, out_filename))
    {
        create_new_file = false;
    }

    // Open the BMP file, validate its header and read the palette.
    FILE *in_file = fopen(in_filename, "rb");
    if (in_file == NULL)
    {
        exit_with_msg("Can't open file %s.\n", in_filename);
    }
    if (fread(header, sizeof(uint8_t), sizeof(header), in_file) != sizeof(header))
    {
        exit_with_msg("Can't read the BMP header in file %s.\n", in_filename);
    }
    if (!is_valid_bmp_file(&palette_offset))
    {
        exit_with_msg("The file %s is not a valid or supported BMP file.\n", in_filename);
    }
    if (fseek(in_file, palette_offset, SEEK_SET) != 0)
    {
        exit_with_msg("Can't access the BMP palette in file %s.\n", in_filename);
    }
    if (fread(palette, sizeof(uint8_t), sizeof(palette), in_file) != sizeof(palette))
    {
        exit_with_msg("Can't read the BMP palette in file %s.\n", in_filename);
    }
    fclose(in_file);

    // Update the colors in the palette.
    convert_palette(rounding_mode);

    // Write the updated palette, either in the original BMP file or a copy of it.
    FILE *out_file = fopen(out_filename, create_new_file ? "wb" : "r+b");
    if (out_file == NULL)
    {
        exit_with_msg("Can't open file %s.\n", out_filename);
    }
    if (create_new_file)
    {
        in_file = fopen(in_filename, "rb");
        if (in_file == NULL)
        {
            exit_with_msg("Can't open file %s.\n", in_filename);
        }
        if (!copy_file(in_file, out_file))
        {
            exit_with_msg("Can't copy file %s to %s.\n", in_filename, out_filename);
        }
        fclose(in_file);
    }
    if (fseek(out_file, palette_offset, SEEK_SET) != 0)
    {
        exit_with_msg("Can't access the BMP palette in file %s.\n", out_filename);
    }
    if (fwrite(palette, sizeof(uint8_t), sizeof(palette), out_file) != sizeof(palette))
    {
        exit_with_msg("Can't write the BMP palette in file %s.\n", out_filename);
    }
    fclose(out_file);

    return 0;
}
